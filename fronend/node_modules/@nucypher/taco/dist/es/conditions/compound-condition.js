import { z } from 'zod';
import { contractConditionSchema } from './base/contract';
import { rpcConditionSchema } from './base/rpc';
import { timeConditionSchema } from './base/time';
import { Condition } from './condition';
export const CompoundConditionType = 'compound';
export const compoundConditionSchema = z
    .object({
    conditionType: z
        .literal(CompoundConditionType)
        .default(CompoundConditionType),
    operator: z.enum(['and', 'or', 'not']),
    operands: z
        .array(z.lazy(() => z.union([
        rpcConditionSchema,
        timeConditionSchema,
        contractConditionSchema,
        compoundConditionSchema,
    ])))
        .min(1),
})
    .refine((condition) => {
    // 'and' and 'or' operators must have at least 2 operands
    if (['and', 'or'].includes(condition.operator)) {
        return condition.operands.length >= 2;
    }
    // 'not' operator must have exactly 1 operand
    if (condition.operator === 'not') {
        return condition.operands.length === 1;
    }
    // We test positive cases exhaustively, so we return false here:
    return false;
}, ({ operands, operator }) => ({
    message: `Invalid number of operands ${operands.length} for operator "${operator}"`,
    path: ['operands'],
}));
export class CompoundCondition extends Condition {
    constructor(value) {
        super(compoundConditionSchema, {
            conditionType: CompoundConditionType,
            ...value,
        });
    }
    static withOperator(operands, operator) {
        const asObjects = operands.map((operand) => {
            if (operand instanceof Condition) {
                return operand.toObj();
            }
            return operand;
        });
        return new CompoundCondition({
            operator,
            operands: asObjects,
        });
    }
    static or(conditions) {
        return CompoundCondition.withOperator(conditions, 'or');
    }
    static and(conditions) {
        return CompoundCondition.withOperator(conditions, 'and');
    }
    static not(condition) {
        return CompoundCondition.withOperator([condition], 'not');
    }
}
//# sourceMappingURL=compound-condition.js.map